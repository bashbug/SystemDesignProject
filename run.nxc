int thresholdBlack = 45; //(dark 0 - 100 light)
bool leftSeesBlack = 0;
bool rightSeesBlack = 0;
bool rightLastBlack;
bool leftLastBlack;
int countBWChanges = 0;
int countTower = 0;
long seesWhiteTime, ttowerfail;
long lastWhiteSeen = 0;

void calibrateLightSensors() {
	TextOut(0, LCD_LINE1, "Kalibrieren?");
	until (ButtonPressed(BTNCENTER, true)) {
		Wait(MS_100);
	}

	int s1 = Sensor(IN_1);
	int s2 = Sensor(IN_2);

	if (s1 > s2) {
		thresholdBlack = s1 - 10;
	} else {
		thresholdBlack = s2 - 10;
	}
	TextOut(0, LCD_LINE3, "Threshold: ");
	NumOut(60, LCD_LINE3, thresholdBlack);
	TextOut(0, LCD_LINE4, "Weiter in 2 Sek");
	Wait(SEC_2);
}


void speed(int speedLeft, int speedRight) { // OUT_A=left Motor; OUT_B=right Motor
	if (speedLeft == speedRight) {
		OnRevSync(OUT_AB, speedLeft, 0);
	}
	OnRev(OUT_A, speedLeft);
	OnRev(OUT_B, speedRight);
}

void lcd(string s) { 
	ClearScreen();
	TextOut(5, LCD_LINE1, s);
}

void backToLine() {
	// erstmal ein Stück rückwärts fahren
	lcd("Back to line");
	speed(-60, -60);
	Wait(MS_500);

	switch (countTower) {
		case 1:
		case 3:
			speed(-60, 60);
			break;
		case 2:
			speed(60, -60);
			break;
	}
	until ((Sensor(IN_1) < thresholdBlack) || (Sensor(IN_2) < thresholdBlack));
	lcd("Found line :-)");
	// Sollte eigentlich überflüssig sein
	speed(30, 30);	
}

void tower() {
	TextOut(0, LCD_LINE1, "Search Tower:");
	NumOut(70, LCD_LINE1, countTower);
	// etwas weiter fahren, damit man besser eindrehen kann
	speed(40,40);
	Wait(MS_200);

	switch (countTower) { 
		case 1:				//erster und dritter ist rechts
		case 3:
			speed(30,-30);
			break;
		case 2:
			speed(-30,30);
			break;
	}

	until (SensorUS(IN_4) < 30) {
		PlayTone(TONE_A4, MS_1);
	}
	PlayTone(TONE_C4, MS_100);
	// MS_200 länger eindrehen
	Wait(MS_200);

	ttowerfail = CurrentTick();
	TextOut(0, LCD_LINE3, "Moving to tower");
	speed(30, 30);

	until (Sensor(IN_3));
	Off(OUT_AB);
	TextOut(0, LCD_LINE4, "Got it!");
	PlayTone(TONE_A4, MS_100);
	backToLine();
}

task move() {
	while (true) {
		rightLastBlack = rightSeesBlack;
		leftLastBlack = leftSeesBlack;
		rightSeesBlack = Sensor(IN_2) < thresholdBlack;
		leftSeesBlack = Sensor(IN_1) < thresholdBlack;

		if (leftSeesBlack || rightSeesBlack) {
			lcd("Straight");
			speed(90, 90);
		}

		if (!leftSeesBlack && !rightSeesBlack) {
			lcd("Lost route");
			PlayTone(TONE_A4, MS_50);

			if (leftLastBlack && rightLastBlack) {
				lcd("Turning back");
				speed(-30, -35);
			} else if (leftLastBlack) {
				lcd("Turning left");
				speed(-10, 70);
			} else if (rightLastBlack) {
				lcd("Turning right");
				speed(70, -10);
			}

			/* 
			 * solange leftSeesBlack und/oder rightSeesBlack false sind fahre weiter
			 * bewegung vom vorherigen until (true)-durchlauf wird noch immer ausgeführt bis schleife
			 * until ((leftSeesBlack || rightSeesBlack)) beendet wird.
			 */
			until (leftSeesBlack || rightSeesBlack) {
				leftSeesBlack = (Sensor(IN_1) < thresholdBlack);
				rightSeesBlack = (Sensor(IN_2) < thresholdBlack);
			}
			/* 
			 * hier wird wieder schwarz gesehen
			 * leftSeesBlack oder rightSeesBlack/beide sehen schwarz
			 */
			seesWhiteTime = CurrentTick();
			int barTimeLength = MS_200;
			countBWChanges++;
			if ((CurrentTick()-seesWhiteTime) > barTimeLength) {
				NumOut(0,LCD_LINE4, seesWhiteTime);
				/* 
				 * wenn zu lange weiss war bis er schwarz gesehen hat
				 * dann wird zurückgesetzt
				 */
				countBWChanges = 0;
			}
			if ((CurrentTick()-lastWhiteSeen) < MS_200 && countBWChanges == 2 && ((CurrentTick()-seesWhiteTime) < barTimeLength)) { 
				/* 
				 * wenn er nach schwarz sehen, innerhalb von ca. 200ms wieder schwarz sieht,
				 * dann erkennt er den barcode. bedeutet, dass er den barcode aber nur anhand
				 * eines weissen striches fest macht.
				 */
				PlayTone(TONE_C4, 200);
				seesWhiteTime = CurrentTick();
				lastWhiteSeen = 0;
				countBWChanges = 0;
				countTower++;
				tower();
			}
			lastWhiteSeen += CurrentTick();
		}
	}
}

task main() {
	//initialize sensors
	SetSensorLight(IN_1); 		// left Light-Sensor
	SetSensorLight(IN_2); 		// right Light-Sensor
	SetSensorTouch(IN_3); 		// touch-Sensor
	SetSensorLowspeed(IN_4); 	// ultrasonic-Sensor
	calibrateLightSensors();
	start move;
}
